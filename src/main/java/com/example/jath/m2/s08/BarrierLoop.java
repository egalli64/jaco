/*
 * Introduction to Java Thread
 * 
 * https://github.com/egalli64/jath
 */
package com.example.jath.m2.s08;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.DoubleAdder;
import java.util.stream.DoubleStream;
import java.util.stream.Stream;

/**
 * Using a CyclicBarrier in a loop, plus interrupting workers and reset barrier.
 */
public class BarrierLoop {
    private static final int TASK_NR = 3;
    private static final int LOOP_NR = 3;
    public static Random random = new Random();

    /**
     * Create a CyclicBarrier for the workers and the main thread.
     * 
     * In a loop, create a thread for a batch of workers and start them. Each worker does its job and
     * waits on the barrier. The main thread wait for the barrier to break, then check for the result
     * generated by the workers.
     * 
     * After that, run a couple of worker but then reset the barrier.
     * 
     * Finally, run a couple of worker but then interrupt one of them.
     * 
     * @param args not used
     */
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(TASK_NR + 1);
        DoubleAdder accumulator = new DoubleAdder();

        Runnable worker = () -> {
            String name = Thread.currentThread().getName();
            double value = job(100);
            System.out.printf("%s: %f%n", name, value);
            accumulator.add(value);
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException ex) {
                long time = System.nanoTime() / 1000 % 10_000;
                System.out.printf("%s, wait interrupted @%d %s %n", name, time, ex);
            }
        };

        // Loop on the barrier
        String name = Thread.currentThread().getName();
        for (int i = 0; i < LOOP_NR; i++) {
            Stream.generate(() -> new Thread(worker)).limit(TASK_NR).forEach(Thread::start);

            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException ex) {
                System.out.printf("%s, wait on barrier interrupted %s%n", name, ex);
            }

            System.out.printf("In %s: %f (%d)%n", name, accumulator.sum(), i);
        }

        // Prepare another loop, but then reset it
        new Thread(worker, "B1").start();
        new Thread(worker, "B2").start();

        // BrokenBarrierException expected for both B1 and B2
        System.out.println("Giving time for the workers to kick in: " + job(10));
        barrier.reset();

        // Prepare another loop, but then interrupt a worker
        Thread ti1 = new Thread(worker, "I1");
        ti1.start();
        new Thread(worker, "I2").start();

        // InterruptedException expected for I1, BrokenBarrierException for I2
        ti1.interrupt();
    }

    /**
     * A useless job
     * 
     * @param size number of random doubles to sum
     * @return sum of a size random doubles in [0, 1)
     */
    private static double job(int size) {
        return DoubleStream.generate(random::nextDouble).limit(size).sum();
    }
}
