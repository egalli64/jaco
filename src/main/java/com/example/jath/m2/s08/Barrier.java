/*
 * Introduction to Java Thread
 * 
 * https://github.com/egalli64/jath
 */
package com.example.jath.m2.s08;

import java.util.Random;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.DoubleAdder;
import java.util.stream.DoubleStream;
import java.util.stream.Stream;

/**
 * CyclicBarrier
 */
public class Barrier {
    private static final int TASK_NR = 3;
    public static Random random = new Random();

    /**
     * Create a CyclicBarrier for the workers and the main thread. Create a thread for each worker and
     * start them. Each worker does its job and waits on the barrier.
     * 
     * The main thread wait for the barrier to break, then check for the result generated by the
     * workers.
     * 
     * @param args not used
     */
    public static void main(String[] args) {
        CyclicBarrier barrier = new CyclicBarrier(TASK_NR + 1);
        DoubleAdder accumulator = new DoubleAdder();

        Runnable worker = () -> {
            String name = Thread.currentThread().getName();
            double value = job(100);
            System.out.printf("%s: %f%n", name, value);
            accumulator.add(value);
            try {
                barrier.await();
            } catch (InterruptedException | BrokenBarrierException ex) {
                System.out.printf("%s, wait on barrier interrupted %s%n", name, ex);
            }
        };

        Stream.generate(() -> new Thread(worker)).limit(TASK_NR).forEach(Thread::start);

        String name = Thread.currentThread().getName();
        try {
            barrier.await();
        } catch (InterruptedException | BrokenBarrierException ex) {
            System.out.printf("%s, wait on barrier interrupted %s%n", name, ex);
        }

        System.out.printf("In %s: %f%n", name, accumulator.sum());
    }

    /**
     * A useless job
     * 
     * @param size number of random doubles to sum
     * @return sum of a size random doubles in [0, 1)
     */
    private static double job(int size) {
        return DoubleStream.generate(random::nextDouble).limit(size).sum();
    }
}
